#!/bin/bash

# Exemple avec ajout d'une bordure de couleur sur la vignette des fichiers mkv en fonction de la résolution d'un fichier mkv pour rapidement différentier les films en LH, HD et UHD


###########################
### Rien de nouveau ici ###
###########################

# Utilisation : keneric FullName mime exportPicture

FullName="$1"
MimeType="$2"
ExportPicture="$3"
Thumb="${ExportPicture##*/}"

# Si on veut un peu mieux comprendre
# echo "keneric $1 $2 $3 $Thumb" >> /tmp/hizo.txt


# Si la vignette existe déjà, on ne fait rien, n'est pas sensé se produire
[[ -e "${HOME}/.cache/thumbnails/large/${Thumb}.png" || -e "${HOME}/.cache/thumbnails/normal/${Thumb}.png" ]] && exit

function Dependencies
{
    # ${@} : Les arguments doivent être de type : commande:paquet ou commande (si paquet = commande)

    local Command 

    # Vérification des dépendances
    for Command in "${@}"
    do
        # Si la commande n'existe pas
        [[ -z $(which ${Command}) ]] && return 1
    done

    return 0
}



# En fonction du type des fichiers
case "${MimeType}" in
    video/x-matroska|video/x-matroska-3d)
        ########################################################################
        ### Gestion des encadrements de couleur en fonction de la résolution ###
        ########################################################################
        # Pour les vidéos en 3D
        if [[ "${MimeType}" == "video/x-matroska-3d" ]]
        then
            BorderColor="purple"

        # Pour les vidéos normales
        else
            if Dependencies mkvinfo
            then
                # Résolution de la vidéo
                Resolution=$(LANG=C.UTF-8 mkvinfo "${FullName}" | sed -n "/+ Pixel width:.*/ s/.* //p")

                # Si c'est de la 3D malgré l'extension
                if LANG=C.UTF-8 mkvinfo "${FullName}" | grep -q "Stereo mode"
                then
                    BorderColor="purple"

                # Si c'est de la 4K
                elif (( Resolution >= 3800 ))
                then
                    BorderColor="black"

                # Si c'est de la HD
                elif (( Resolution >= 1900 ))
                then
                    BorderColor="navy"

                # Si c'est de la LD
                elif (( Resolution < 1900 ))
                then
                    BorderColor="grey"

                # Sinon
                else
                    BorderColor="white"
                fi

            else
                BorderColor="white"
            fi
        fi

        # Si les dépendances sont présentes, on va rechercher une image dans le mkv
        if Dependencies jq mkvmerge mkvextract
        then
            # Récupération de la liste des fichiers joints
            mapfile -td 'µ' jsonValues < <(mkvmerge -J "${FullName}" | jq -r '.attachments | to_entries|map("\(.value)µ")|.[]')
            unset jsonValues["-1"]

            # Boucle recherchant certaines images
            for FichierJoint in "${jsonValues[@]}"
            do
                # Récupération du nom de la piste
                [[ "${FichierJoint}" =~ file_name.:.([^\"]+) ]]
                Name="${BASH_REMATCH[1]}"

                # Récupération de l'id de la piste
                [[ "${FichierJoint}" =~ id.:([0-9]+) ]]
                Id="${BASH_REMATCH[1]}"

                # Si on a pas pu récupérer l'id du fichier joint
                [[ -z ${Id} ]] && continue

                # Si c'est une image
                if [[ "${Name,,}" == *.+(jpg|jpeg|png|webp|gif) ]]
                then
                    # Si le fichier a un nom spécifique
                    if [[ "${Name,,}" == +(cover|front|dvd).* ]]
                    then
                        ImageList=("${Id}:/tmp/${Name}")
                        break

                    # Dans les autres cas, on la conserve
                    else
                        ImageList+=("${Id}:/tmp/${Name}")
                    fi
                fi
            done

            # Utilisation de la 1ere image trouvée
            if [[ ${ImageList[0]} ]]
            then
                # Extraction de l'image
                mkvextract attachments "${FullName}" ${ImageList[0]%%:*}:"${ImageList[0]#*:}" &>/dev/null

                if Dependencies convert
                then
                    ##################################################
                    ### Resize de l'image avec ajout d'une bordure ###
                    ##################################################
                    convert -resize "256x256>" -bordercolor ${BorderColor} -border 5 "${ImageList[0]#*:}" "${ExportPicture}"

                else
                    # Sinon, c'est un simple renommage de fichier
                    mv "${ImageList[0]#*:}" "${ExportPicture}"
                fi

                # Suppression de l'image extraite
                rm "${ImageList[0]#*:}"

                exit 0
            fi
        fi

        # Si les dépendances ne sont pas bonnes ou qu'il n'y a pas d'image dans le mkv
        Dependencies ffmpegthumbnailer && ffmpegthumbnailer -s 256 -i "${FullName}" -o "${ExportPicture}"

        ###########################
        ### Ajout d'une bordure ###
        ###########################
        if Dependencies convert
        then
            convert -bordercolor ${BorderColor} -border 5 "${ExportPicture}" "${ExportPicture}"
        fi

        exit 0 ;;
esac
